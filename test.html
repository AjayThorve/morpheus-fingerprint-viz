<!DOCTYPE html>
<html lang="en">

<head>
    <title>three.js webgl - orbit controls</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <link type="text/css" rel="stylesheet" href="./test/main.css">
    <style>
        body {
            background-color: #ccc;
            color: #000;
        }

        a {
            color: #f00;
        }
    </style>
</head>

<body>
    <div id="info">
        <button id="clickme">Click me</button>
        <a href="https://threejs.org" target="_blank" rel="noopener">three.js</a> - orbit controls
    </div>

    <!-- Import maps polyfill -->
    <!-- Remove this when import maps will be widely supported -->
    <script async src="https://unpkg.com/es-module-shims@1.3.6/dist/es-module-shims.js"></script>

    <script type="importmap">
			{
				"imports": {
					"three": "./test/three.js"
				}
			}
		</script>

    <script type="module">

        import * as THREE from 'three';

        import { MapControls } from './test/OrbitControls.js';

        let camera, controls, scene, renderer, mesh, rows, cols, hexRadius;

        init();
        //render(); // remove when using next line for animation loop (requestAnimationFrame)
        animate();

        function update() {
            const positions = new Float32Array([
                1, 0, 0, 0,
                0, Math.random() * 100, 0, 0,
                0, 0, 1, 0,
                0, 1, 0, 1,

                1, 0, 0, 0,
                0, Math.random() * 100, 0, 0,
                0, 0, 1, 0,
                34.64101791381836, 1, 0, 1,

                1, 0, 0, 0,
                0, Math.random() * 100, 0, 0,
                0, 0, 1, 0,
                69.28203582763672, 1, 0, 1,
            ])
            const colors = new Float32Array([
                1 * Math.random(), 0.0039 * Math.random(), 1 * Math.random(),
                1 * Math.random(), 1 * Math.random(), 1 * Math.random(),
                1 * Math.random(), 1 * Math.random(), 1 * Math.random(),
            ])
            mesh.instanceMatrix = new THREE.InstancedBufferAttribute(positions, 16);
            mesh.instanceColor = new THREE.InstancedBufferAttribute(colors, 3);
        }

        document.getElementById("clickme").onclick = update;

        function init() {

            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xffffff);
            // scene.fog = new THREE.FogExp2(0xcccccc, 0.002);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            camera = new THREE.OrthographicCamera(window.innerWidth / - 2, window.innerWidth / 2, window.innerHeight / 2, window.innerHeight / - 2, -5000, 5000);
            // camera.zoom = 0.1;
            camera.position.set(0, 1, 1);

            // controls

            controls = new MapControls(camera, renderer.domElement);
            controls.listenToKeyEvents(window); // optional

            //controls.addEventListener( 'change', render ); // call this only in static scenes (i.e., if there is no animation loop)

            // controls.enableDamping = true; // an animation loop is required when either damping or auto-rotation are enabled
            // controls.dampingFactor = 0.05;

            controls.screenSpacePanning = true;

            controls.minDistance = 0;
            controls.maxDistance = 1500;

            controls.maxPolarAngle = Math.PI / 2;

            // world


            // for (let i = 0; i < 500; i++) {

            //     const mesh = new THREE.Mesh(geometry, material);
            //     mesh.position.x = Math.random() * 1600 - 800;
            //     mesh.position.y = 0;
            //     mesh.position.z = Math.random() * 1600 - 800;
            //     mesh.updateMatrix();
            //     mesh.matrixAutoUpdate = false;
            //     scene.add(mesh);

            // }

            rows = 25000
            cols = 100
            hexRadius = 20

            const geometry = new THREE.CylinderGeometry(hexRadius - 4, hexRadius - 4, 1, 6, 1);
            geometry.translate(0, 0.5, 0);
            const material = new THREE.MeshPhongMaterial({ flatShading: true });
            mesh = new THREE.InstancedMesh(geometry, material, rows * cols);
            scene.add(mesh);

            const dummy = new THREE.Object3D()


            const positions = new Float32Array([
                1, 0, 0, 0,
                0, 277, 0, 0,
                0, 0, 1, 0,
                0, 1, 0, 1,

                1, 0, 0, 0,
                0, 283, 0, 0,
                0, 0, 1, 0,
                34.64101791381836, 1, 0, 1,

                1, 0, 0, 0,
                0, 283, 0, 0,
                0, 0, 1, 0,
                69.28203582763672, 1, 0, 1,
            ])

            // mesh.instanceMatrix = new THREE.InstancedBufferAttribute(positions, 16);
            let el = 0;
            console.log(new THREE.Color().setHex(0x002288));
            for (var i = 0; i < rows; i++) {
                for (var j = 0; j < cols; j++) {
                    let x = hexRadius * j * Math.sqrt(3);
                    //Offset each uneven row by half of a "hex-width" to the right
                    if (i % 2 === 1) {
                        x = x + (hexRadius * Math.sqrt(3)) / 2
                    }
                    var y = hexRadius * i * 1.5;

                    dummy.position.set(x, 1, y);
                    dummy.scale.y = Math.floor(Math.random() * 300);
                    dummy.updateMatrix();

                    mesh.setColorAt(el, new THREE.Color().setHex(Math.floor(Math.random() * 16777215).toString(16)));
                    mesh.setMatrixAt(el, dummy.matrix);
                    el++;
                    // const mesh = new THREE.Mesh(geometry, material);
                    // mesh.position.x = x;
                    // mesh.position.y = 0;
                    // mesh.position.z = y;
                    // mesh.scale.y = Math.floor(Math.random() * 300);
                    // mesh.updateMatrix();
                    // mesh.matrixAutoUpdate = false;
                }//for j
            }


            // lights

            const dirLight1 = new THREE.DirectionalLight(0xffffff);
            dirLight1.position.set(1, 1, 1);
            scene.add(dirLight1);

            // const dirLight2 = new THREE.DirectionalLight();
            // dirLight2.position.set(200, 200, -1);
            // scene.add(dirLight2);

            const ambientLight = new THREE.AmbientLight(0x002288);
            scene.add(ambientLight);



            window.addEventListener('resize', onWindowResize);

        }

        function onWindowResize() {

            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();

            renderer.setSize(window.innerWidth, window.innerHeight);

        }

        function animate() {

            requestAnimationFrame(animate);

            controls.update(); // only required if controls.enableDamping = true, or if controls.autoRotate = true

            render();

        }

        function render() {

            renderer.render(scene, camera);

        }

    </script>

</body>

</html>